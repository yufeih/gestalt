import { AlignContent, AlignItems, AlignSelf, BorderStyle, Color, Column, DangerouslySetInlineStyle, Dimension, Direction, Display, Flex, JustifyContent, Margin, Opacity, Overflow, Padding, Position, UserSelect } from './boxTypes';
import { ToPropsOutput } from './style';
import { Functor } from './transforms';
import { Indexable } from './zIndex';
type MarginFunctorType = Functor<Margin>;
type PaddingFunctor = Functor<Padding>;
export declare const propToFn: {
    readonly alignItems: Functor<AlignItems>;
    readonly display: Functor<Display>;
    readonly column: Functor<Column>;
    readonly direction: Functor<Direction>;
    readonly smAlignItems: Functor<AlignItems>;
    readonly smDisplay: Functor<Display>;
    readonly smColumn: Functor<Column>;
    readonly smDirection: Functor<Direction>;
    readonly mdAlignItems: Functor<AlignItems>;
    readonly mdDisplay: Functor<Display>;
    readonly mdColumn: Functor<Column>;
    readonly mdDirection: Functor<Direction>;
    readonly lgAlignItems: Functor<AlignItems>;
    readonly lgDisplay: Functor<Display>;
    readonly lgColumn: Functor<Column>;
    readonly lgDirection: Functor<Direction>;
    readonly alignContent: Functor<AlignContent>;
    readonly alignSelf: Functor<AlignSelf>;
    readonly bottom: Functor<boolean>;
    readonly borderStyle: Functor<BorderStyle>;
    readonly color: Functor<Color>;
    readonly fit: Functor<boolean>;
    readonly flex: Functor<Flex>;
    readonly flexBasis: Functor<string | number>;
    readonly height: Functor<Dimension>;
    readonly justifyContent: Functor<JustifyContent>;
    readonly left: Functor<boolean>;
    readonly margin: MarginFunctorType;
    readonly marginTop: MarginFunctorType;
    readonly marginBottom: MarginFunctorType;
    readonly marginStart: MarginFunctorType;
    readonly marginEnd: MarginFunctorType;
    readonly smMargin: MarginFunctorType;
    readonly smMarginTop: MarginFunctorType;
    readonly smMarginBottom: MarginFunctorType;
    readonly smMarginStart: MarginFunctorType;
    readonly smMarginEnd: MarginFunctorType;
    readonly mdMargin: MarginFunctorType;
    readonly mdMarginTop: MarginFunctorType;
    readonly mdMarginBottom: MarginFunctorType;
    readonly mdMarginStart: MarginFunctorType;
    readonly mdMarginEnd: MarginFunctorType;
    readonly lgMargin: MarginFunctorType;
    readonly lgMarginTop: MarginFunctorType;
    readonly lgMarginBottom: MarginFunctorType;
    readonly lgMarginStart: MarginFunctorType;
    readonly lgMarginEnd: MarginFunctorType;
    readonly maxHeight: Functor<Dimension>;
    readonly maxWidth: Functor<Dimension>;
    readonly minHeight: Functor<Dimension>;
    readonly minWidth: Functor<Dimension>;
    readonly opacity: Functor<Opacity>;
    readonly overflow: Functor<Overflow>;
    readonly padding: PaddingFunctor;
    readonly paddingX: PaddingFunctor;
    readonly paddingY: PaddingFunctor;
    readonly smPadding: PaddingFunctor;
    readonly smPaddingX: PaddingFunctor;
    readonly smPaddingY: PaddingFunctor;
    readonly mdPadding: PaddingFunctor;
    readonly mdPaddingX: PaddingFunctor;
    readonly mdPaddingY: PaddingFunctor;
    readonly lgPadding: PaddingFunctor;
    readonly lgPaddingX: PaddingFunctor;
    readonly lgPaddingY: PaddingFunctor;
    readonly position: Functor<Position>;
    readonly right: Functor<boolean>;
    readonly rounding: (rounding: import("./getRoundingClassName").Rounding) => import("./style").Style;
    readonly top: Functor<boolean>;
    readonly userSelect: Functor<UserSelect>;
    readonly width: Functor<Dimension>;
    readonly wrap: Functor<boolean>;
    readonly dangerouslySetInlineStyle: Functor<DangerouslySetInlineStyle>;
    readonly zIndex: Functor<Indexable | null | undefined>;
};
export declare function buildStyles<T extends any>({ baseStyles, props, blocklistProps, allowlistProps, }: {
    baseStyles: string;
    props: T;
    blocklistProps?: ReadonlyArray<string>;
    allowlistProps?: ReadonlyArray<string>;
}): {
    passthroughProps: T;
    propsStyles: ToPropsOutput;
};
export {};
